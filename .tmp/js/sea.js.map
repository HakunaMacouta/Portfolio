{"version":3,"sources":["sea.js"],"names":["vertexShader","fragmentShader","initGeometry","seaGeometry","THREE","PlaneBufferGeometry","rotateX","Math","PI","initShader","uniforms","uMap","type","value","uTime","uColor","Color","seaShader","ShaderMaterial","side","DoubleSide","textureLoader","TextureLoader","load","texture","wrapS","wrapT","REPEAT_WRAPPING","initSeaMesh","seaMesh","Mesh","scene","add"],"mappings":";;AAAA,IAAIA,gsBAAJ;;AA0BA,IAAIC,4vBAAJ;;AAuBA,SAASC,YAAT,GAAwB;AACpBC,kBAAc,IAAIC,MAAMC,mBAAV,CAA8B,GAA9B,EAAmC,GAAnC,EAAwC,EAAxC,EAA4C,EAA5C,CAAd;AACAF,gBAAYG,OAAZ,CAAoB,CAACC,KAAKC,EAAN,GAAW,CAA/B;AACH;;AAED,SAASC,UAAT,GAAsB;AAClB,QAAIC,WAAW;AACXC,cAAM,EAACC,MAAM,GAAP,EAAYC,OAAO,IAAnB,EADK;AAEXC,eAAO,EAACF,MAAM,GAAP,EAAYC,OAAO,CAAnB,EAFI;AAGXE,gBAAQ,EAACH,MAAM,GAAP,EAAYC,OAAO,IAAIT,MAAMY,KAAV,CAAgB,SAAhB,CAAnB;AAHG,KAAf;;AAMAC,gBAAY,IAAIb,MAAMc,cAAV,CAAyB;AACjCR,kBAAUA,QADuB;AAEjCV,sBAAcA,YAFmB;AAGjCC,wBAAgBA,cAHiB;AAIjCkB,cAAMf,MAAMgB;AAJqB,KAAzB,CAAZ;;AAOA,QAAIC,gBAAgB,IAAIjB,MAAMkB,aAAV,EAApB;AACAD,kBAAcE,IAAd,CAAmB,gDAAnB,EAAqE,UAAUC,OAAV,EAAmB;AACpFP,kBAAUP,QAAV,CAAmBC,IAAnB,CAAwBE,KAAxB,GAAgCW,OAAhC;AACAA,gBAAQC,KAAR,GAAgBD,QAAQE,KAAR,GAAgBtB,MAAMuB,eAAtC;AACH,KAHD;AAIH;;AAED,SAASC,WAAT,GAAuB;AACnBC,cAAU,IAAIzB,MAAM0B,IAAV,CAAe3B,WAAf,EAA4Bc,SAA5B,CAAV;AACAc,UAAMC,GAAN,CAAUH,OAAV;AACH","file":"sea.js","sourcesContent":["var vertexShader = `\n#define SCALE 10.0\n\nvarying vec2 vUv;\n\nuniform float uTime;\n\nfloat calculateSurface(float x, float z) {\n    float y = 0.0;\n    y += (sin(x * 1.0 / SCALE + uTime * 1.0) + sin(x * 2.3 / SCALE + uTime * 1.5) + sin(x * 3.3 / SCALE + uTime * 0.4)) / 3.0;\n    y += (sin(z * 0.2 / SCALE + uTime * 1.8) + sin(z * 1.8 / SCALE + uTime * 1.8) + sin(z * 2.8 / SCALE + uTime * 0.8)) / 3.0;\n    return y;\n}\n\nvoid main() {\n    vUv = uv;\n    vec3 pos = position;\n    \n    float strength = 1.0;\n    pos.y += strength * calculateSurface(pos.x, pos.z);\n    pos.y -= strength * calculateSurface(0.0, 0.0);\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}  \n`;\n\nvar fragmentShader = `\nvarying vec2 vUv;\n\nuniform sampler2D uMap;\nuniform float uTime;\nuniform vec3 uColor;\n\nvoid main() {\n    vec2 uv = vUv * 10.0 + vec2(uTime * -0.05);\n\n    uv.y += 0.01 * (sin(uv.x * 3.5 + uTime * 0.35) + sin(uv.x * 4.8 + uTime * 1.05) + sin(uv.x * 7.3 + uTime * 0.45)) / 3.0;\n    uv.x += 0.12 * (sin(uv.y * 4.0 + uTime * 0.5) + sin(uv.y * 6.8 + uTime * 0.75) + sin(uv.y * 11.3 + uTime * 0.2)) / 3.0;\n    uv.y += 0.12 * (sin(uv.x * 4.2 + uTime * 0.64) + sin(uv.x * 6.3 + uTime * 1.65) + sin(uv.x * 8.2 + uTime * 0.45)) / 3.0;\n\n    vec4 tex1 = texture2D(uMap, uv * 1.0);\n    vec4 tex2 = texture2D(uMap, uv * 1.0 + vec2(0.2));\n\n    vec3 blue = uColor;\n\n    gl_FragColor = vec4(blue + vec3(tex1.a * 0.9 - tex2.a * 0.02), 1.0);\n}\n`;\n\nfunction initGeometry() {\n    seaGeometry = new THREE.PlaneBufferGeometry(100, 100, 20, 20);\n    seaGeometry.rotateX(-Math.PI / 2);\n}\n\nfunction initShader() {\n    var uniforms = {\n        uMap: {type: 't', value: null},\n        uTime: {type: 'f', value: 0},\n        uColor: {type: 'f', value: new THREE.Color('#0051da')},\n    };\n\n    seaShader = new THREE.ShaderMaterial({\n        uniforms: uniforms,\n        vertexShader: vertexShader,\n        fragmentShader: fragmentShader,\n        side: THREE.DoubleSide,\n    });\n\n    var textureLoader = new THREE.TextureLoader();\n    textureLoader.load('https://cinemont.com/tutorials/zelda/water.png', function (texture) {\n        seaShader.uniforms.uMap.value = texture;\n        texture.wrapS = texture.wrapT = THREE.REPEAT_WRAPPING;\n    });\n}\n\nfunction initSeaMesh() {\n    seaMesh = new THREE.Mesh(seaGeometry, seaShader);\n    scene.add(seaMesh);\n}"]}